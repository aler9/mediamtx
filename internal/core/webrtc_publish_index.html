<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<style>
html, body {
	margin: 0;
	padding: 0;
	height: 100%;
	overflow: hidden;
}
body {
    display: flex;
    flex-direction: column;
}
#video {
	height: 100%;
	background: black;
    flex-grow: 1;
    min-height: 0;
}
#controls {
    height: 200px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}
#idle, #device {
    gap: 20px;
}
select {
    width: 200px;
}
</style>
</head>
<body>

<video id="video" muted controls autoplay playsinline></video>
<div id="controls">
    <div id="idle" style="display: flex;">
        <button id="publish_devices">publish video and audio</button>
        <button id="publish_screen">publish screen</button>
    </div>
    <div id="device" style="display: none;">
        video device:
        <select id="video_device">
            <option value="none">none</option>
        </select>

        audio device:
        <select id="audio_device">
            <option value="none">none</option>
        </select>

        <button id="publish_confirm">publish</button>
    </div>
    <div id="transmitting" style="display: none;">
        transmitting
    </div>
</div>

<script>

const IDLE = 0;
const DEVICE = 1;
const TRANSMITTING = 2;

let state = IDLE;

const setState = (newState) => {
    state = newState;

    switch (state) {
    case DEVICE:
        document.getElementById("idle").style.display = 'none';
        document.getElementById("device").style.display = 'flex';
        document.getElementById("transmitting").style.display = 'none';
        break;

    case TRANSMITTING:
        document.getElementById("idle").style.display = 'none';
        document.getElementById("device").style.display = 'none';
        document.getElementById("transmitting").style.display = 'flex';
        break;
    }
};

const restartPause = 2000;

class Transmitter {
    constructor(stream) {
        this.stream = stream;
        this.terminated = false;
		this.ws = null;
		this.pc = null;
		this.restartTimeout = null;
		this.start();
    }

    start = () => {
        console.log("connecting");

        this.ws = new WebSocket(window.location.href.replace(/^http/, "ws") + '/ws');

        this.ws.onerror = () => {
            console.log("ws error");
            if (this.ws === null) {
                return;
            }
            this.ws.close();
            this.ws = null;
        };

        this.ws.onclose = () => {
            console.log("ws closed");
            this.ws = null;
            this.scheduleRestart();
        };

        this.ws.onmessage = this.onIceServers;
    };

    scheduleRestart = () => {
        if (this.terminated) {
            return;
        }

        if (this.ws !== null) {
            this.ws.close();
            this.ws = null;
        }

        if (this.pc !== null) {
            this.pc.close();
            this.pc = null;
        }

        this.restartTimeout = window.setTimeout(() => {
            this.restartTimeout = null;
            this.start();
        }, restartPause);
    };

    onIceServers = (msg) => {
        if (this.ws === null) {
            return;
        }

        this.pc = new RTCPeerConnection({
            iceServers: JSON.parse(msg.data),
        });

        this.ws.onmessage = this.onOffer;
    };

    onOffer = (msg) => {
        if (this.ws === null || this.pc === null) {
            return;
        }

        this.stream.getTracks().forEach((track) => {
            this.pc.addTrack(track, this.stream);
        });

        this.ws.onmessage = (msg) => {
            if (this.pc === null) {
                return;
            }
            this.pc.addIceCandidate(JSON.parse(msg.data));
        };

        this.pc.onicecandidate = (evt) => {
            if (this.ws === null) {
                return;
            }

            if (evt.candidate !== null) {
                if (evt.candidate.candidate !== "") {
                    this.ws.send(JSON.stringify(evt.candidate));
                }
            }
        };

        this.pc.oniceconnectionstatechange = () => {
            if (this.pc === null) {
                return;
            }

            console.log("peer connection state:", this.pc.iceConnectionState);

            switch (this.pc.iceConnectionState) {
            case "failed":
            case "disconnected":
                this.scheduleRestart();
            }
        };

        this.pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(msg.data)));

        this.pc.createAnswer()
            .then((desc) => {
                if (this.ws === null || this.pc === null) {
                    return;
                }

                this.pc.setLocalDescription(desc);
                this.ws.send(JSON.stringify(desc));
            });
    };
}

const onStream = (stream) => {
    setState(TRANSMITTING);
    document.getElementById('video').srcObject = stream;
    new Transmitter(stream);
};

const onPublishDevices = () => {
    navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then(() => navigator.mediaDevices.enumerateDevices())
        .then((devices) => {
            for (const device of devices) {
                switch (device.kind) {
                case 'videoinput':
                    {
                        const opt = document.createElement('option');
                        opt.value = device.deviceId;
                        opt.text = device.label;
                        document.getElementById('video_device').appendChild(opt);
                    }
                    break;

                case 'audioinput':
                    {
                        const opt = document.createElement('option');
                        opt.value = device.deviceId;
                        opt.text = device.label;
                        document.getElementById('audio_device').appendChild(opt);
                    }
                    break;
                }
            }

            setState(DEVICE);
        });
};

const onPublishScreen = () => {
    return navigator.mediaDevices.getDisplayMedia({
        video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: { ideal: 30 },
            cursor: "always",
        },
        audio: false,
    })
        .then(onStream);
};

const onPublishDeviceConfirm = () => {
    let video = false;
    const videoId = document.getElementById('video_device').value;
    if (videoId !== 'none') {
        video = {
            deviceId: videoId,
        };
    }

    let audio = false;
    const audioId = document.getElementById('audio_device').value;
    if (audioId !== 'none') {
        audio = {
            deviceId: audioId,
        };
    }

    navigator.mediaDevices.getUserMedia({ video, audio })
        .then(onStream);
};

document.getElementById("publish_devices").addEventListener('click', onPublishDevices);
document.getElementById("publish_screen").addEventListener('click', onPublishScreen);
document.getElementById("publish_confirm").addEventListener('click', onPublishDeviceConfirm);

</script>

</body>
</html>
